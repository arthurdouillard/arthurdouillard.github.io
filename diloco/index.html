<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DiLoCo Bandwidth Simulator</title>
    <style>
        :root {
            /* Color Palette */
            --bg-body: #f8fafc;
            --bg-card: #ffffff;
            
            --slate-50: #f8fafc;
            --slate-100: #f1f5f9;
            --slate-200: #e2e8f0;
            --slate-300: #cbd5e1;
            --slate-400: #94a3b8;
            --slate-500: #64748b;
            --slate-600: #475569;
            --slate-700: #334155;
            --slate-800: #1e293b;
            --slate-900: #0f172a;

            --blue-50: #fff7ed;
            --blue-100: #ffedd5;
            --blue-200: #fed7aa;
            --blue-500: #f97316;
            --blue-600: #d95f0e;
            --blue-700: #c2410c;
            --blue-900: #7c2d12;

            --green-50: #f0fdf4;
            --green-100: #dcfce7;
            --green-200: #bbf7d0;
            --green-400: #4ade80;
            --green-600: #16a34a;
            --green-800: #166534;

            --indigo-500: #6366f1;
            --purple-200: #e9d5ff;
            --purple-500: #a855f7;
            --purple-600: #9333ea;
            --red-500: #ef4444;
            --orange-50: #fff7ed;
            --orange-600: #ea580c;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-body);
            color: var(--slate-800);
            line-height: 1.5;
            margin: 0;
            padding: 2rem;
        }

        /* Layout */
        .container {
            max-width: 64rem;
            margin: 0 auto;
        }

        .header {
            margin-bottom: 2rem;
            border-bottom: 2px solid var(--slate-200);
            padding-bottom: 1rem;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #d95f0e;
            margin: 0;
        }

        .header p {
            font-size: 0.875rem;
            color: var(--slate-500);
            margin-top: 0.5rem;
        }
        
        .header a {
            color: #d95f0e;
            text-decoration: none;
        }
        .header a:hover {
            text-decoration: underline;
        }

        .grid-2-cols {
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        @media (min-width: 1024px) {
            .grid-2-cols {
                grid-template-columns: 1fr 1fr;
            }
        }

        /* Panels */
        .panel {
            background-color: var(--bg-card);
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border: 1px solid var(--slate-100);
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .results-panel {
            background-color: #fff7ed;
            border: 1px solid #ffedd5;
        }

        /* Typography */
        .section-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--slate-700);
            margin-bottom: 0.5rem;
            border-bottom: 1px solid var(--slate-100);
            padding-bottom: 0.5rem;
        }
        
        .result-title {
            font-size: 1.125rem;
            font-weight: 700;
            color: #7c2d12;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .label-sm {
            display: block;
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--slate-500);
            margin-bottom: 0.25rem;
        }

        .label-sub {
            font-size: 0.65rem;
            color: var(--slate-400);
            margin-top: 0.25rem;
        }

        /* Forms */
        .input-group-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .form-control {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--slate-300);
            border-radius: 0.375rem;
            font-size: 0.875rem;
            background-color: var(--slate-50);
            color: var(--slate-700);
            font-weight: 500;
            box-sizing: border-box;
            outline: none;
        }

        .form-control:focus {
            outline: 2px solid var(--blue-600);
            outline-offset: 1px;
            border-color: var(--blue-600);
        }

        .input-addon-group {
            display: flex;
            align-items: center;
        }
        
        .input-addon-group input {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        .input-addon {
            background-color: var(--slate-100);
            border: 1px solid var(--slate-300);
            border-left: 0;
            color: var(--slate-500);
            font-size: 0.65rem;
            padding: 0.5rem 0.75rem;
            border-top-right-radius: 0.375rem;
            border-bottom-right-radius: 0.375rem;
            display: flex;
            align-items: center;
            height: 100%;
            box-sizing: border-box;
            line-height: 1.25rem; /* Match input line-height approx */
        }
        
        /* Fix for input height matching */
        .form-control { height: 2.5rem; } 

        .flex-between-center {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Toggle Switch */
        .toggle-container {
            margin-top: 1rem;
            background-color: var(--green-50);
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid var(--green-100);
        }
        
        .toggle-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .toggle-title {
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--green-800);
        }

        .toggle-desc {
            font-size: 0.65rem;
            color: var(--green-600);
            margin-top: 0.125rem;
        }

        .toggle-wrapper {
            position: relative;
            display: inline-block;
            width: 2.5rem;
            height: 1.25rem;
        }

        .toggle-checkbox {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #cbd5e1;
            transition: .2s;
            border-radius: 9999px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 1.25rem;
            width: 1.25rem;
            left: 0;
            bottom: 0;
            background-color: white;
            transition: .2s;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .toggle-checkbox:checked + .toggle-slider {
            background-color: var(--green-400);
        }

        .toggle-checkbox:checked + .toggle-slider:before {
            transform: translateX(100%);
            border-color: var(--green-400);
        }
        
        .streaming-options {
            display: none; /* Hidden by default via JS */
            border-top: 1px solid var(--green-200); 
            padding-top: 0.75rem; 
            margin-top: 0.5rem;
        }
        
        .streaming-options.active {
            display: grid;
        }

        /* Results & Bars */
        .result-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--blue-200);
            padding-bottom: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .result-key {
            font-size: 0.875rem;
            color: var(--blue-900);
        }

        .result-val {
            font-family: 'SF Mono', 'Roboto Mono', monospace;
            font-weight: 700;
            font-size: 1.125rem;
            color: var(--blue-900);
        }

        .result-val-sm {
            font-family: 'SF Mono', 'Roboto Mono', monospace;
            font-weight: 700;
            font-size: 0.875rem;
            color: var(--slate-800);
        }

        .bar-group {
            margin-top: 0.5rem;
            margin-bottom: 1rem;
        }

        .bar-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.875rem;
            color: var(--slate-600);
            margin-bottom: 0.25rem;
        }

        .bar-track {
            width: 100%;
            height: 0.375rem;
            background-color: var(--blue-200);
            border-radius: 9999px;
            overflow: hidden;
            position: relative;
        }

        .bar-fill-blue { background-color: var(--blue-600); height: 100%; transition: width 0.3s; }
        .bar-fill-indigo { background-color: var(--indigo-500); height: 100%; transition: width 0.3s; }
        .bar-fill-purple { background-color: var(--purple-500); height: 100%; transition: width 0.3s; }
        .bar-fill-purple-ghost { background-color: var(--purple-200); height: 100%; transition: width 0.3s; }

        .total-row {
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 2px solid var(--blue-200);
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }

        .total-val {
            font-family: 'SF Mono', 'Roboto Mono', monospace;
            font-weight: 700;
            font-size: 1.875rem;
            color: var(--blue-700);
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 0.75rem;
            border-top: 1px solid var(--blue-200);
            padding-top: 0.75rem;
        }

        .tag {
            font-size: 0.65rem;
            font-weight: 400;
            color: var(--slate-400);
            background-color: var(--slate-100);
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            margin-left: 0.5rem;
        }

        .line-through { text-decoration: line-through; color: var(--slate-400) !important; }
        .hidden { display: none !important; }

        /* Code Block */
        .code-block {
            background-color: var(--slate-900);
            color: var(--slate-300);
            padding: 1rem;
            border-radius: 0.5rem;
            font-family: monospace;
            font-size: 0.75rem;
            overflow-x: auto;
            margin-top: 1.5rem;
        }
        
        .code-title {
            color: var(--slate-100);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            font-size: 0.65rem;
        }

        /* Plot Container */
        .plot-section {
            margin-bottom: 3rem;
            width: 100%;
        }

        .plot-box {
            background: white;
            border: 1px solid var(--slate-200);
            border-radius: 0.5rem;
            overflow: visible;
            width: 100%;
            height: 400px;
            box-sizing: border-box;
            padding: 1rem;
        }

        /* Utilities */
        .text-green-400 { color: var(--green-400); }
        .text-blue-400 { color: var(--blue-400); }
        .text-slate-300 { color: var(--slate-300); }
        .text-green-600 { color: var(--green-600); }
        .text-orange-600 { color: var(--orange-600); }
        .text-red-500 { color: var(--red-500); }
        .text-green-500 { color: #22c55e; }
        .font-bold { font-weight: 700; }
        .text-right { text-align: right; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-4 { margin-bottom: 1rem; }

        .overlap-detail {
            font-family: monospace;
            font-size: 0.65rem;
            text-align: right;
            background: rgba(255,255,255,0.5);
            padding: 0.25rem;
            border: 1px solid var(--blue-100);
            border-radius: 0.25rem;
            margin-top: 0.25rem;
        }

        /* FAQ */
        .faq-section {
            margin-top: 3rem;
            border-top: 1px solid var(--slate-200);
            padding-top: 2rem;
        }
        .faq-item { margin-bottom: 1.5rem; }
        .faq-q { font-weight: 600; font-size: 0.875rem; color: var(--slate-800); }
        .faq-a { font-size: 0.875rem; color: var(--slate-600); margin-top: 0.25rem; }

        /* Hardware section specific */
        .hardware-box {
            background-color: var(--slate-50);
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--slate-200);
        }

        /* Tooltip */
        .tooltip-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .tooltip-bubble {
            visibility: hidden;
            opacity: 0;
            background-color: var(--slate-800);
            color: white;
            text-align: center;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            font-size: 0.75rem;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        .tooltip-bubble::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: var(--slate-800) transparent transparent transparent;
        }

        .tooltip-wrapper:hover .tooltip-bubble {
            visibility: visible;
            opacity: 1;
        }

        .form-control:disabled {
            background-color: var(--slate-200);
            color: var(--slate-400);
            cursor: not-allowed;
        }

        /* Save Configuration Button */
        .save-config-btn {
            width: 100%;
            padding: 0.75rem;
            background-color: var(--blue-600);
            color: white;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            font-size: 0.875rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .save-config-btn:hover {
            background-color: var(--blue-700);
        }

        .save-config-btn:active {
            transform: scale(0.98);
        }

        /* Configuration Cards */
        .config-card {
            background-color: white;
            border: 2px solid var(--blue-200);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
            position: relative;
            transition: all 0.2s;
        }

        .config-card:hover {
            border-color: var(--blue-400);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.2);
        }

        .config-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }

        .config-name {
            font-weight: 700;
            font-size: 1rem;
            color: var(--blue-900);
            margin-bottom: 0.25rem;
        }

        .config-util {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--blue-600);
            font-family: 'SF Mono', 'Roboto Mono', monospace;
        }

        .config-params {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            font-size: 0.75rem;
            color: var(--slate-600);
        }

        .config-param {
            display: flex;
            justify-content: space-between;
        }

        .config-param-label {
            color: var(--slate-500);
        }

        .config-param-value {
            font-weight: 600;
            color: var(--slate-700);
            font-family: 'SF Mono', 'Roboto Mono', monospace;
        }

        .delete-config-btn {
            background-color: var(--red-500);
            color: white;
            border: none;
            border-radius: 0.375rem;
            padding: 0.375rem 0.75rem;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .delete-config-btn:hover {
            background-color: #dc2626;
        }

        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--slate-400);
        }

        .empty-state svg {
            margin: 0 auto 1rem;
            opacity: 0.5;
        }

        /* Share Button */
        .share-btn {
            padding: 0.5rem 1rem;
            background-color: var(--green-600);
            color: white;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            font-size: 0.875rem;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            transition: background-color 0.2s;
        }

        .share-btn:hover {
            background-color: var(--green-800);
        }

        .share-btn:active {
            transform: scale(0.98);
        }

        .share-btn.copied {
            background-color: var(--blue-600);
        }

        /* Bandwidth Table */
        .bandwidth-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
            table-layout: fixed;
        }

        .bandwidth-table th {
            background-color: var(--slate-100);
            color: var(--slate-700);
            font-weight: 600;
            padding: 0.5rem 0.25rem;
            text-align: center;
            border: 1px solid var(--slate-200);
            white-space: nowrap;
        }

        .bandwidth-table td {
            padding: 0.5rem 0.25rem;
            text-align: center;
            border: 1px solid var(--slate-200);
            font-family: 'SF Mono', 'Roboto Mono', monospace;
            font-weight: 500;
        }

        .bandwidth-table .method-name {
            font-weight: 700;
            text-align: left;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            white-space: nowrap;
        }

        .bandwidth-table tbody tr:hover {
            background-color: var(--slate-50);
        }

        @media (max-width: 640px) {
            .bandwidth-table {
                font-size: 0.75rem;
            }
            .bandwidth-table th,
            .bandwidth-table td {
                padding: 0.375rem 0.125rem;
            }
        }

        /* Navigation Header */
        .top-nav {
            background-color: var(--bg-card);
            border-bottom: 1px solid var(--slate-200);
            padding: 1rem 2rem;
            margin: -2rem -2rem 2rem -2rem;
        }

        .top-nav a {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            color: var(--slate-800);
            font-weight: 600;
            font-size: 1rem;
            transition: color 0.2s;
        }

        .top-nav a:hover {
            color: #d95f0e;
        }

        .top-nav img {
            height: 18px;
            width: 18px;
        }
    </style>
</head>
<body class="container">

    <nav class="top-nav">
        <a href="../index.html">
            <img src="../favicon.ico" alt="Home">
            Arthur Douillard
        </a>
    </nav>

    <header class="header">
        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
            <div>
                <h1>DiLoCo Bandwidth Simulator</h1>
                <p>
                    Based on the papers:
                    <a href="https://arxiv.org/abs/2311.08105" target="_blank">DiLoCo</a>,
                    <a href="https://arxiv.org/abs/2501.18512" target="_blank">Streaming DiLoCo</a>,
                    <a href="https://arxiv.org/abs/2503.09799" target="_blank">Scaling Laws for DiLoCo</a>
                </p>
            </div>
            <button id="shareBtn" class="share-btn" title="Copy shareable URL to clipboard">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                    <polyline points="15 3 21 3 21 9"></polyline>
                    <line x1="10" y1="14" x2="21" y2="3"></line>
                </svg>
                Share Config
            </button>
        </div>
    </header>

    <!-- Top Configuration Panel -->
    <div class="panel" style="margin-bottom: 2rem;">
        <h2 class="section-title">Model & Network Configuration</h2>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
            <div>
                <label class="label-sm">Model Size</label>
                <input type="text" id="modelSizeInput" value="10" class="form-control formatted-input model-size-input">
                <div class="label-sub">Billion parameters (N)</div>
            </div>

            <div>
                <label class="label-sm">Compute Time per Step</label>
                <input type="text" id="secondsPerStep" value="1.0" class="form-control formatted-input">
                <div class="label-sub">Seconds</div>
            </div>

            <div>
                <label class="label-sm">Number of Datacenters</label>
                <input type="text" id="numDatacenters" value="2" class="form-control formatted-input">
                <div class="label-sub">M (≥1)</div>
            </div>

        </div>
    </div>

    <!-- Hardcoded Configurations -->
    <div style="display: flex; flex-direction: column; gap: 0.5rem; margin-bottom: 2rem;">

        <!-- Configuration 1: Data Parallel -->
        <div class="panel" style="padding: 0.5rem 0.75rem;">
            <h2 class="section-title" style="color: #94a3b8; border-color: #94a3b8; font-size: 0.875rem; margin-bottom: 0.25rem; padding-bottom: 0;">Data Parallel (H=1)</h2>

            <div style="display: flex; gap: 0.75rem; align-items: center;">
                <div style="flex: 1;">
                    <label class="label-sm">Gradients Data Type</label>
                    <select id="dp_dtype" class="form-control">
                        <option value="2" selected>bfloat16 (2 bytes)</option>
                        <option value="1">fp8 (1 byte)</option>
                        <option value="0.5">fp4 (0.5 bytes)</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Configuration 2: DiLoCo -->
        <div class="panel" style="padding: 0.5rem 0.75rem;">
            <h2 class="section-title" style="color: #ef4444; border-color: #ef4444; font-size: 0.875rem; margin-bottom: 0.25rem; padding-bottom: 0;">DiLoCo</h2>

            <div style="display: flex; gap: 0.75rem; align-items: flex-end;">
                <div style="flex: 1;">
                    <label class="label-sm">Gradients Data Type</label>
                    <select id="diloco_dtype" class="form-control">
                        <option value="2" selected>bfloat16 (2 bytes)</option>
                        <option value="1">fp8 (1 byte)</option>
                        <option value="0.5">fp4 (0.5 bytes)</option>
                    </select>
                </div>

                <div style="flex: 1;">
                    <label class="label-sm">Synchronization Cadence (H)</label>
                    <input type="text" id="diloco_H" value="30" class="form-control formatted-input">
                </div>
            </div>
        </div>

        <!-- Configuration 3: Streaming DiLoCo with Overlap -->
        <div class="panel" style="padding: 0.rem 0.75rem;">
            <h2 class="section-title" style="color: #f97316; border-color: #f97316; font-size: 0.875rem; margin-bottom: 0.25rem; padding-bottom: 0;">Streaming DiLoCo with Overlap</h2>

            <div style="display: flex; gap: 0.75rem; align-items: flex-end;">
                <div style="flex: 1;">
                    <label class="label-sm">Gradients Data Type</label>
                    <select id="streaming_dtype" class="form-control">
                        <option value="2" selected>bfloat16 (2 bytes)</option>
                        <option value="1">fp8 (1 byte)</option>
                        <option value="0.5">fp4 (0.5 bytes)</option>
                    </select>
                </div>

                <div style="flex: 1;">
                    <label class="label-sm">Fragment Period (H)</label>
                    <input type="text" id="streaming_H" value="100" class="form-control formatted-input">
                </div>

                <div style="flex: 1;">
                    <label class="label-sm">Fragments (P)</label>
                    <input type="text" id="streaming_P" value="16" class="form-control formatted-input">
                </div>

                <div style="flex: 1;">
                    <label class="label-sm">Overlap Delay (τ)</label>
                    <input type="text" id="streaming_S" value="1" class="form-control formatted-input">
                </div>
            </div>

            <div style="background-color: #fff7ed; border: 1px solid #fed7aa; border-radius: 0.375rem; padding: 0.5rem; margin-top: 0.5rem;">
                <div style="font-size: 0.65rem; color: #d95f0e; line-height: 1.4;">
                    <strong>Streaming pattern:</strong> H is the period for <em>each</em> fragment. With P fragments, one fragment is sent every <strong id="fragment_interval_display">5.0</strong> steps. Fragment size = total_size / P.
                </div>
            </div>
        </div>
    </div>

    <!-- Bandwidth Requirements Table -->
    <div class="panel" style="margin-bottom: 2rem;">
        <h2 class="section-title">Bandwidth Requirements for Target Utilization</h2>
        <p style="font-size: 0.875rem; color: var(--slate-600); margin-bottom: 1rem;">
            Approximate inter-datacenter bandwidth (Gbps) needed to achieve each compute utilization (CU) threshold:
        </p>
        <div style="overflow-x: auto; -webkit-overflow-scrolling: touch;">
            <table id="bandwidthTable" class="bandwidth-table">
                <thead>
                    <tr>
                        <th>Method</th>
                        <th>50% CU</th>
                        <th>75% CU</th>
                        <th>90% CU</th>
                        <th>95% CU</th>
                        <th>99% CU</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td class="method-name" style="background-color: #f8fafc;">Data Parallel</td>
                        <td id="dp_50">-</td>
                        <td id="dp_75">-</td>
                        <td id="dp_90">-</td>
                        <td id="dp_95">-</td>
                        <td id="dp_99">-</td>
                    </tr>
                    <tr>
                        <td class="method-name" style="background-color: #fef2f2;">DiLoCo</td>
                        <td id="diloco_50">-</td>
                        <td id="diloco_75">-</td>
                        <td id="diloco_90">-</td>
                        <td id="diloco_95">-</td>
                        <td id="diloco_99">-</td>
                    </tr>
                    <tr>
                        <td class="method-name" style="background-color: #fff7ed;">Streaming DiLoCo</td>
                        <td id="streaming_50">-</td>
                        <td id="streaming_75">-</td>
                        <td id="streaming_90">-</td>
                        <td id="streaming_95">-</td>
                        <td id="streaming_99">-</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- Figure 4 Plot -->
    <div class="plot-section">
        <h3 class="section-title" style="border:0; margin-bottom: 0.5rem;">Compute Utilization</h3>
        <p style="font-size: 0.875rem; color: var(--slate-600); margin-bottom: 1rem;">
            For all methods, the reduction of gradients or outer gradients is overlapped over the backward pass computation.
        </p>
        <div id="figure4Plot" class="plot-box" style="position: relative;">
            <!-- Chart injected here -->
        </div>
    </div>

    <!-- Footer -->
    <footer style="margin-top: 4rem; padding-top: 2rem; border-top: 1px solid var(--slate-200); text-align: center; color: var(--slate-500); font-size: 0.875rem;">
        <p>
            Originally forked from <a href="https://mino98.github.io/diloco-calculator/" target="_blank" style="color: var(--blue-500); text-decoration: none;">mino98's DiLoCo Calculator</a>.
        </p>
    </footer>

    <!-- Hidden fields for fixed parameters -->
    <input type="hidden" id="totalSteps" value="1000">
    <input type="hidden" id="totalChips" value="100">
    <input type="hidden" id="interBw" value="100">

<script>
    // ========================================================================
    // TIMELINE + NETWORK QUEUE SIMULATOR
    // ========================================================================

    // Input Formatting Logic
    const formatNumber = (num) => {
        if (!num && num !== 0) return '';
        const cleanStr = num.toString().replace(/,/g, '');
        const val = parseFloat(cleanStr);
        if (isNaN(val)) return cleanStr;
        return val.toLocaleString('en-US');
    };

    const parseNumber = (str) => {
        if (!str) return 0;
        return parseFloat(str.replace(/,/g, '')) || 0;
    };

    // Get model size in actual parameter count (not billions)
    const getModelSize = () => {
        const input = document.getElementById('modelSizeInput');
        if (!input) return 10e9; // Default fallback
        const billions = parseNumber(input.value);
        return billions * 1e9;
    };

    function formatCapacity(bps) {
        const gbps = bps / 1e9;
        if (gbps < 1000) {
            return gbps.toFixed(1) + " Gbps";
        }
        const tbps = gbps / 1000;
        if (tbps < 1000) {
            return tbps.toFixed(2) + " Tbps";
        }
        const pbps = tbps / 1000;
        return pbps.toFixed(2) + " Pbps";
    }

    // Attach listeners
    document.querySelectorAll('.formatted-input').forEach(input => {
        input.value = formatNumber(input.value);
        input.addEventListener('focus', function() {
            this.value = this.value.replace(/,/g, '');
            this.select();
        });
        input.addEventListener('blur', function() {
            this.value = formatNumber(this.value);
        });
        input.addEventListener('input', updateConfigurations);
    });

    // Model Size Input with special formatting
    const modelSizeInput = document.getElementById('modelSizeInput');
    modelSizeInput.addEventListener('focus', function() {
        this.value = this.value.replace(/,/g, '');
        this.select();
    });
    modelSizeInput.addEventListener('blur', function() {
        const val = parseFloat(this.value.replace(/,/g, '')) || 10;
        // Add comma formatting for values >= 1000
        if (val >= 1000) {
            this.value = val.toLocaleString('en-US');
        } else {
            this.value = val.toString();
        }
    });
    modelSizeInput.addEventListener('input', updateConfigurations);

    // Wire up all input listeners for global settings
    document.getElementById('numDatacenters').addEventListener('input', updateConfigurations);
    document.getElementById('secondsPerStep').addEventListener('input', updateConfigurations);

    // Wire up listeners for configuration-specific inputs
    document.getElementById('dp_dtype').addEventListener('change', updateConfigurations);
    document.getElementById('diloco_dtype').addEventListener('change', updateConfigurations);
    document.getElementById('diloco_H').addEventListener('input', updateConfigurations);
    document.getElementById('streaming_dtype').addEventListener('change', updateConfigurations);
    document.getElementById('streaming_H').addEventListener('input', updateConfigurations);
    document.getElementById('streaming_P').addEventListener('input', updateConfigurations);
    document.getElementById('streaming_S').addEventListener('input', updateConfigurations);

    function formatTime(seconds) {
        if (seconds < 0) return "0s";
        if (seconds < 60) return seconds.toFixed(1) + "s";
        const d = Math.floor(seconds / (3600 * 24));
        const h = Math.floor((seconds % (3600 * 24)) / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);

        if (d > 0) return `${d}d ${h}h ${m}m`;
        if (h > 0) return `${h}h ${m}m ${s}s`;
        return `${m}m ${s}s`;
    }

    // ========================================================================
    // CORE SIMULATION: Timeline + Network Queue
    // ========================================================================

    /**
     * Generate bucketed gradient release schedule
     * @param {number} K - Number of buckets
     * @param {number} T_step - Total step time
     * @param {number} T_fwd - Forward pass time
     * @param {number} T_bwd - Backward pass time
     * @param {number} S_total_bits - Total bits to communicate
     * @returns {Array} Array of {release_offset, size_bits}
     */
    function makeBuckets(K, T_step, T_fwd, T_bwd, S_total_bits) {
        const buckets = [];
        for (let k = 0; k < K; k++) {
            buckets.push({
                release_offset: T_fwd + ((k + 1) / K) * T_bwd,
                size_bits: S_total_bits / K
            });
        }
        return buckets;
    }

    /**
     * Calculate communication time
     * @param {number} size_bits - Size in bits
     * @param {number} B_bps - Bandwidth in bits/s
     * @param {number} alpha - Latency per collective (seconds)
     * @returns {number} Communication time in seconds
     */
    function commTime(size_bits, B_bps, alpha) {
        return alpha + size_bits / B_bps;
    }

    /**
     * Simulate Data Parallel with bucketed all-reduce
     * @param {Object} params - {N, T_step, T_fwd, T_bwd, K, S_total_bits, B_gbps, alpha, N_steps, M}
     * @returns {Object} {CU, total_compute_time, total_stall_time, num_steps}
     */
    function simulateDP(params) {
        const { N, T_step, T_fwd, T_bwd, K, S_total_bits, B_gbps, alpha, N_steps, M } = params;
        const B_bps = B_gbps * 1e9;

        // Generate buckets
        const buckets = makeBuckets(K, T_step, T_fwd, T_bwd, S_total_bits);

        // Network queue state
        let net_free_time = 0;

        // Compute clock
        let t = 0;
        let stall_total = 0;
        let total_compute_time = 0;

        // Simulate N inner steps
        for (let step = 0; step < N_steps; step++) {
            const step_start = t;
            const jobs = [];

            // Generate communication jobs for each bucket
            buckets.forEach((bucket, k) => {
                // Apply multi-datacenter overhead: 2 * (1 - 1/M) factor
                const overhead_factor = M > 1 ? 2 * (1 - 1/M) : 0;
                const effective_size = bucket.size_bits * overhead_factor;

                if (effective_size > 0) {
                    jobs.push({
                        release_time: step_start + bucket.release_offset,
                        deadline_time: step_start + T_step,
                        size_bits: effective_size,
                        tag: `step${step}_bucket${k}`
                    });
                }
            });

            // Schedule jobs on network queue
            let max_stall = 0;
            jobs.forEach(job => {
                const start = Math.max(job.release_time, net_free_time);
                const duration = commTime(job.size_bits, B_bps, alpha);
                const finish = start + duration;
                net_free_time = finish;

                // Check if we missed deadline
                const stall = Math.max(0, finish - job.deadline_time);
                max_stall = Math.max(max_stall, stall);
            });

            // Apply stall to compute clock
            t += max_stall;
            stall_total += max_stall;

            // Advance compute
            t += T_step;
            total_compute_time += T_step;
        }

        const CU = total_compute_time / (total_compute_time + stall_total);

        return {
            CU: CU * 100,
            total_compute_time,
            total_stall_time: stall_total,
            num_steps: N_steps,
            mode: 'Data Parallel'
        };
    }

    /**
     * Simulate DiLoCo with outer synchronization
     * @param {Object} params - {N, T_step, H, S_outer_bits, B_gbps, alpha, N_steps, M}
     * @returns {Object} {CU, total_compute_time, total_stall_time, num_steps}
     */
    function simulateDiLoCo(params) {
        const { N, T_step, H, S_outer_bits, B_gbps, alpha, N_steps, M } = params;
        const B_bps = B_gbps * 1e9;

        // Network queue state
        let net_free_time = 0;

        // Compute clock
        let t = 0;
        let stall_total = 0;
        let total_compute_time = 0;

        // Simulate N inner steps
        for (let step = 0; step < N_steps; step++) {
            const step_start = t;

            // Check if this is an outer sync step
            if ((step + 1) % H === 0) {
                // Apply multi-datacenter overhead
                const overhead_factor = M > 1 ? 2 * (1 - 1/M) : 0;
                const effective_size = S_outer_bits * overhead_factor;

                if (effective_size > 0) {
                    const job = {
                        release_time: step_start + T_step,
                        deadline_time: step_start + T_step,
                        size_bits: effective_size,
                        tag: `outer_sync_step${step}`
                    };

                    // Schedule on network queue
                    const start = Math.max(job.release_time, net_free_time);
                    const duration = commTime(job.size_bits, B_bps, alpha);
                    const finish = start + duration;
                    net_free_time = finish;

                    // Check if we missed deadline (creates bubble)
                    const stall = Math.max(0, finish - job.deadline_time);
                    t += stall;
                    stall_total += stall;
                }
            }

            // Advance compute
            t += T_step;
            total_compute_time += T_step;
        }

        const CU = total_compute_time / (total_compute_time + stall_total);

        return {
            CU: CU * 100,
            total_compute_time,
            total_stall_time: stall_total,
            num_steps: N_steps,
            mode: 'DiLoCo'
        };
    }

    /**
     * Simulate Streaming DiLoCo with continuous fragment streaming
     * H is the period for EACH fragment (not the full outer update)
     * With P fragments, one fragment is sent every H/P steps
     * @param {Object} params - {N, T_step, T_fwd, T_bwd, H, P, tau, S_outer_bits, B_gbps, alpha, N_steps, M, K}
     * @returns {Object} {CU, total_compute_time, total_stall_time, num_steps}
     */
    function simulateStreamingDiLoCo(params) {
        const { N, T_step, T_fwd, T_bwd, H, P, tau, S_outer_bits, B_gbps, alpha, N_steps, M, K } = params;
        const B_bps = B_gbps * 1e9;

        // Fragment size (each fragment = 1/P of total model)
        const fragment_size = S_outer_bits / P;

        // Fragment interval: one fragment sent every H/P steps
        const fragment_interval = H / P;

        // Network queue state
        let net_free_time = 0;

        // Compute clock
        let t = 0;
        let stall_total = 0;
        let total_compute_time = 0;

        // Simulate N inner steps
        for (let step = 0; step < N_steps; step++) {
            const step_start = t;
            const jobs = [];

            // Check if we should send a fragment at this step
            // Fragment streaming pattern: every H/P steps, send the next fragment in rotation
            const current_fragment_slot = Math.floor((step % H) / fragment_interval);
            const prev_fragment_slot = Math.floor(((step - 1 + H) % H) / fragment_interval);

            // Send a fragment if we've entered a new fragment slot
            if (step === 0 || current_fragment_slot !== prev_fragment_slot) {
                const fragment_id = current_fragment_slot;

                // Apply multi-datacenter overhead
                const overhead_factor = M > 1 ? 2 * (1 - 1/M) : 0;
                const effective_size = fragment_size * overhead_factor;

                if (effective_size > 0) {
                    // Release fragment during backward pass (simplified: at end of backward)
                    const fragment_release_offset = T_fwd + T_bwd;

                    jobs.push({
                        release_time: step_start + fragment_release_offset,
                        deadline_time: step_start + (tau + 1) * T_step,
                        size_bits: effective_size,
                        tag: `step${step}_frag${fragment_id}`
                    });
                }
            }

            // Schedule jobs on network queue
            let max_stall = 0;
            jobs.forEach(job => {
                const start = Math.max(job.release_time, net_free_time);
                const duration = commTime(job.size_bits, B_bps, alpha);
                const finish = start + duration;
                net_free_time = finish;

                // Check if we missed deadline
                const stall = Math.max(0, finish - job.deadline_time);
                max_stall = Math.max(max_stall, stall);
            });

            // Apply stall to compute clock
            t += max_stall;
            stall_total += max_stall;

            // Advance compute
            t += T_step;
            total_compute_time += T_step;
        }

        const CU = total_compute_time / (total_compute_time + stall_total);

        return {
            CU: CU * 100,
            total_compute_time,
            total_stall_time: stall_total,
            num_steps: N_steps,
            mode: 'Streaming DiLoCo'
        };
    }

    /**
     * Calculate number of fragments from model size
     * Based on paper configurations
     */
    function getNumFragments(num_params) {
        // Paper configurations:
        // 1B → 8 fragments
        // 10B → 16 fragments
        // 100B → 36 fragments
        // 1T → 40 fragments

        if (num_params <= 2e9) {
            return 8;   // 1B-2B models
        } else if (num_params <= 15e9) {
            return 16;  // 3B-15B models
        } else if (num_params <= 150e9) {
            return 36;  // 20B-150B models
        } else {
            return 40;  // 200B+ models
        }
    }

    /**
     * Wrapper function to call appropriate simulator
     */
    function calculateCore(H, bytesPerParam, S, P_user, overrideInterBw) {
        // Fetch global values
        const N = getModelSize();
        const secondsPerStep = parseNumber(document.getElementById('secondsPerStep').value);
        const M = parseNumber(document.getElementById('numDatacenters').value);
        const B_gbps = overrideInterBw !== undefined ? overrideInterBw : 100; // default

        // Use user-provided P value
        const P = P_user;

        // Simulation parameters
        const N_steps = 2000; // Number of steps to simulate
        const T_step = secondsPerStep;
        const T_fwd = T_step / 3;
        const T_bwd = T_step * 2 / 3;
        const K = 16; // Number of buckets
        const alpha = 0.002; // 2ms latency per collective

        // Calculate data sizes in bits
        const S_total_bits = N * bytesPerParam * 8; // Convert bytes to bits
        const S_outer_bits = S_total_bits; // Outer sync same size as gradients

        // Determine which simulation to run
        let result;
        if (H === 1) {
            // Data Parallel
            result = simulateDP({
                N, T_step, T_fwd, T_bwd, K,
                S_total_bits,
                B_gbps,
                alpha,
                N_steps,
                M
            });
        } else if (S > 0 || P > 1) {
            // Streaming DiLoCo
            result = simulateStreamingDiLoCo({
                N, T_step, T_fwd, T_bwd,
                H, P,
                tau: S, // S is the overlap delay
                S_outer_bits,
                B_gbps,
                alpha,
                N_steps,
                M,
                K
            });
        } else {
            // Standard DiLoCo
            result = simulateDiLoCo({
                N, T_step,
                H,
                S_outer_bits,
                B_gbps,
                alpha,
                N_steps,
                M
            });
        }

        return {
            utilization: result.CU,
            mode: result.mode,
            T_comp: result.total_compute_time,
            T_comm_inter: result.total_stall_time,
            T_total: result.total_compute_time + result.total_stall_time,
            N, M, H, bytesPerParam, S, P, B_gbps
        };
    }

    function updateConfigurations() {
        // Update fragment interval display
        const H = parseNumber(document.getElementById('streaming_H').value);
        const P = parseNumber(document.getElementById('streaming_P').value);
        const fragment_interval = H / P;
        const intervalDisplay = document.getElementById('fragment_interval_display');
        if (intervalDisplay) {
            intervalDisplay.textContent = fragment_interval.toFixed(1);
        }

        // Update the plot
        updatePlot();

        // Update the bandwidth requirements table
        updateBandwidthTable();

        // Update URL with current configuration
        updateURL();
    }


    function updateTimelineVisualizations() {
        const container = document.getElementById('timelineVisualizations');
        if(!container) return;

        // Get configuration values
        const secondsPerStep = parseNumber(document.getElementById('secondsPerStep').value);
        const diloco_H = parseNumber(document.getElementById('diloco_H').value);
        const streaming_H = parseNumber(document.getElementById('streaming_H').value);
        const streaming_P = parseNumber(document.getElementById('streaming_P').value);
        const streaming_S = parseNumber(document.getElementById('streaming_S').value);

        const numSteps = 3; // Show 3 steps for visualization

        // Timeline configuration
        const timelineHeight = 120;
        const rowHeight = 45;
        const padding = { left: 100, right: 40, top: 20, bottom: 20 };

        // Create timelines for each method
        const timelines = [
            {
                name: 'Data Parallel',
                color: '#94a3b8',
                description: 'H=1 (synchronize every step)',
                generateTimeline: () => generateDataParallelTimeline(numSteps, secondsPerStep)
            },
            {
                name: 'DiLoCo',
                color: '#ef4444',
                description: `H=${diloco_H} (synchronize every ${diloco_H} steps)`,
                generateTimeline: () => generateDiLoCoTimeline(numSteps, secondsPerStep, diloco_H)
            },
            {
                name: 'Streaming DiLoCo with Overlap',
                color: '#f97316',
                description: `H=${streaming_H}, P=${streaming_P}, S=${streaming_S}`,
                generateTimeline: () => generateStreamingDiLoCoTimeline(numSteps, secondsPerStep, streaming_H, streaming_P, streaming_S)
            }
        ];

        let html = '';
        timelines.forEach(timeline => {
            const data = timeline.generateTimeline();
            const totalWidth = padding.left + data.totalTime * 200 + padding.right; // 200px per second for more space

            html += `
                <div class="panel">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <div>
                            <h4 style="font-size: 1rem; font-weight: 700; color: ${timeline.color}; margin: 0;">${timeline.name}</h4>
                            <p style="font-size: 0.75rem; color: var(--slate-500); margin: 0.25rem 0 0 0;">${timeline.description}</p>
                        </div>
                    </div>
                    <div style="overflow-x: auto; overflow-y: hidden;">
                        ${renderTimeline(data, totalWidth, timelineHeight, padding, timeline.color)}
                    </div>
                </div>
            `;
        });

        container.innerHTML = html;
    }

    function generateDataParallelTimeline(numSteps, stepTime) {
        const events = [];
        let currentTime = 0;

        for (let step = 0; step < numSteps; step++) {
            // Compute (forward + backward)
            events.push({
                type: 'compute',
                start: currentTime,
                duration: stepTime,
                label: `step ${step}`,
                stepTime: stepTime
            });
            currentTime += stepTime;

            // Communication (all gradients)
            events.push({
                type: 'wan',
                start: currentTime,
                duration: stepTime * 0.3, // Assuming comm takes 30% of step time for visualization
                label: 'GR',
                stepTime: stepTime
            });
            currentTime += stepTime * 0.3;
        }

        return { events, totalTime: currentTime };
    }

    function generateDiLoCoTimeline(numSteps, stepTime, H) {
        const events = [];
        let currentTime = 0;

        for (let step = 0; step < numSteps; step++) {
            // Compute (forward + backward)
            events.push({
                type: 'compute',
                start: currentTime,
                duration: stepTime,
                label: `step ${step}`,
                stepTime: stepTime
            });
            currentTime += stepTime;

            // Communication only every H steps
            if ((step + 1) % H === 0) {
                events.push({
                    type: 'wan',
                    start: currentTime,
                    duration: stepTime * 0.3,
                    label: 'GR',
                    stepTime: stepTime
                });
                currentTime += stepTime * 0.3;
            }
        }

        return { events, totalTime: currentTime };
    }

    function generateStreamingDiLoCoTimeline(numSteps, stepTime, H, P, S) {
        const events = [];
        let currentTime = 0;
        const fragmentInterval = H / P;
        let nextFragmentStep = fragmentInterval;
        let fragmentsSent = 0;

        for (let step = 0; step < numSteps; step++) {
            const stepStart = currentTime;

            // Compute (forward + backward)
            events.push({
                type: 'compute',
                start: currentTime,
                duration: stepTime,
                label: `step ${step}`,
                stepTime: stepTime
            });

            // Check if we should send a fragment at this step
            if (step > 0 && step >= nextFragmentStep - 0.5) {
                // Fragment communication overlaps with current computation
                const fragmentDuration = (stepTime * 0.3) / P; // Each fragment is smaller
                const fragmentStart = stepStart + stepTime * 0.3; // Start partway through compute

                events.push({
                    type: 'wan',
                    start: fragmentStart,
                    duration: fragmentDuration,
                    label: `GR${fragmentsSent % P}`,
                    stepTime: stepTime,
                    overlap: true
                });

                nextFragmentStep += fragmentInterval;
                fragmentsSent++;
            }

            currentTime += stepTime;
        }

        return { events, totalTime: currentTime };
    }

    function renderTimeline(data, width, height, padding, color) {
        const scale = (width - padding.left - padding.right) / data.totalTime;
        const rowHeight = 45;
        const rowSpacing = 10;

        let svg = `<svg width="${width}" height="${height}" style="font-family: sans-serif; font-size: 0.75rem;">`;
        svg += `<rect width="100%" height="100%" fill="#fafafa" />`;

        // Row labels
        svg += `<text x="${padding.left - 10}" y="${padding.top + rowHeight/2 + 5}" text-anchor="end" fill="#64748b" font-weight="600" font-size="0.875rem">WAN</text>`;
        svg += `<text x="${padding.left - 10}" y="${padding.top + rowHeight + rowSpacing + rowHeight/2 + 5}" text-anchor="end" fill="#64748b" font-weight="600" font-size="0.875rem">COMPUTE</text>`;

        // Timeline axis
        const axisY = height - 25;
        svg += `<line x1="${padding.left}" y1="${axisY}" x2="${width - padding.right}" y2="${axisY}" stroke="#cbd5e1" stroke-width="1"/>`;

        // Time labels
        for (let t = 0; t <= data.totalTime; t += 0.5) {
            const x = padding.left + t * scale;
            svg += `<line x1="${x}" y1="${axisY}" x2="${x}" y2="${axisY + 4}" stroke="#cbd5e1" stroke-width="1"/>`;
            if (t % 1 === 0) {
                svg += `<text x="${x}" y="${axisY + 16}" text-anchor="middle" fill="#64748b" font-size="0.75rem">${t.toFixed(1)}</text>`;
            }
        }
        svg += `<text x="${width - padding.right + 15}" y="${axisY + 5}" fill="#64748b" font-size="0.75rem">Time [s]</text>`;

        // Render events
        data.events.forEach(event => {
            const x = padding.left + event.start * scale;
            const w = event.duration * scale;
            const y = event.type === 'wan'
                ? padding.top
                : padding.top + rowHeight + rowSpacing;

            if (event.type === 'compute') {
                // Split into forward and backward
                const forwardPasses = 4;
                const backwardPasses = 4;
                const totalPasses = forwardPasses + backwardPasses;
                const passWidth = w / totalPasses;

                // Forward passes (blue)
                for (let i = 0; i < forwardPasses; i++) {
                    const px = x + i * passWidth;
                    svg += `<rect x="${px}" y="${y}" width="${passWidth - 2}" height="${rowHeight}" fill="#f97316" stroke="white" stroke-width="2" rx="2"/>`;
                    svg += `<text x="${px + passWidth/2}" y="${y + rowHeight/2 + 5}" text-anchor="middle" fill="white" font-size="0.75rem" font-weight="700">F${i}</text>`;
                }

                // Backward passes (green)
                for (let i = 0; i < backwardPasses; i++) {
                    const px = x + (forwardPasses + i) * passWidth;
                    const shade = i % 2 === 0 ? '#22c55e' : '#16a34a';
                    svg += `<rect x="${px}" y="${y}" width="${passWidth - 2}" height="${rowHeight}" fill="${shade}" stroke="white" stroke-width="2" rx="2"/>`;
                    svg += `<text x="${px + passWidth/2}" y="${y + rowHeight/2 + 5}" text-anchor="middle" fill="white" font-size="0.75rem" font-weight="700">BW${3-i}</text>`;
                }

                // Step label above
                svg += `<text x="${x + w/2}" y="${y - 5}" text-anchor="middle" fill="#475569" font-size="0.875rem" font-weight="700">${event.label} [${event.stepTime.toFixed(2)} s]</text>`;
            } else if (event.type === 'wan') {
                // Communication (purple)
                svg += `<rect x="${x}" y="${y}" width="${w}" height="${rowHeight}" fill="${color}" stroke="white" stroke-width="2" rx="3"/>`;
                svg += `<text x="${x + w/2}" y="${y + rowHeight/2 + 5}" text-anchor="middle" fill="white" font-size="0.875rem" font-weight="700">${event.label}</text>`;
            }
        });

        svg += `</svg>`;
        return svg;
    }

    function updatePlot() {
        const container = document.getElementById('figure4Plot');
        if(!container) return;

        // Use direct container dimensions from DOM
        const width = container.clientWidth || 600;
        const height = 400; // Hardcoded fixed height to prevent vertical compression
        const padding = { top: 20, right: 20, bottom: 40, left: 50 };

        // Get global config
        const N = getModelSize();
        const secondsPerStep = parseNumber(document.getElementById('secondsPerStep').value);
        const M = parseNumber(document.getElementById('numDatacenters').value);

        // Get configuration-specific settings
        const dp_dtype = parseFloat(document.getElementById('dp_dtype').value);
        const diloco_dtype = parseFloat(document.getElementById('diloco_dtype').value);
        const diloco_H = parseNumber(document.getElementById('diloco_H').value);
        const streaming_dtype = parseFloat(document.getElementById('streaming_dtype').value);
        const streaming_H = parseNumber(document.getElementById('streaming_H').value);
        const streaming_P = parseNumber(document.getElementById('streaming_P').value);
        const streaming_S = parseNumber(document.getElementById('streaming_S').value);

        // Per-Step calculations
        const T_comp_step = secondsPerStep; 

        // Sweep Configuration: 0.1G to 1000G
        const bwPoints = [];
        for (let exp = -1; exp <= 3; exp += 0.1) {
            bwPoints.push(Math.pow(10, exp));
        }

        // Series Definitions based on hardcoded configurations
        const seriesConfig = [
            { name: "Data Parallel", color: "#94a3b8" },
            { name: "DiLoCo", color: "#ef4444" },
            { name: "Streaming DiLoCo with Overlap", color: "#f97316" }
        ];

        const seriesData = seriesConfig.map(() => []);

        bwPoints.forEach(bw => {
            // Calculate for each configuration at this bandwidth
            const dp_res = calculateCore(1, dp_dtype, 0, 1, bw);
            const diloco_res = calculateCore(diloco_H, diloco_dtype, 0, 1, bw);
            const streaming_res = calculateCore(streaming_H, streaming_dtype, streaming_S, streaming_P, bw);

            seriesData[0].push({ x: bw, y: dp_res.utilization });
            seriesData[1].push({ x: bw, y: diloco_res.utilization });
            seriesData[2].push({ x: bw, y: streaming_res.utilization });
        });

        // SVG Drawing
        let svg = `<svg width="100%" height="100%" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg" style="font-family: sans-serif; font-size: 0.75rem;">`;
        svg += `<rect width="100%" height="100%" fill="white" />`;

        const minX = Math.log(0.1);
        const maxX = Math.log(1000);
        const scaleX = (val) => padding.left + ((Math.log(val) - minX) / (maxX - minX)) * (width - padding.left - padding.right);
        const scaleY = (val) => height - padding.bottom - (val / 100) * (height - padding.top - padding.bottom);

        // Grid & Y Axis
        for (let i = 0; i <= 100; i += 20) {
            const y = scaleY(i);
            svg += `<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" stroke="#e2e8f0" />`;
            svg += `<text x="${padding.left - 5}" y="${y + 3}" text-anchor="end" fill="#64748b">${i}%</text>`;
        }
        
        // X Axis & Grid (Logarithmic)
        const majorTicks = [0.1, 1, 10, 100, 1000];
        const labels = ["10⁻¹", "10⁰", "10¹", "10²", "10³"];
        
        // Minor grid lines
        for (let i = -1; i < 3; i++) {
            const base = Math.pow(10, i);
            for (let j = 2; j < 10; j++) {
                const val = base * j;
                const x = scaleX(val);
                svg += `<line x1="${x}" y1="${height - padding.bottom}" x2="${x}" y2="${padding.top}" stroke="#f1f5f9" />`;
            }
        }

        majorTicks.forEach((val, i) => {
            const x = scaleX(val);
            svg += `<line x1="${x}" y1="${height - padding.bottom}" x2="${x}" y2="${padding.top}" stroke="#cbd5e1" stroke-dasharray="4" />`;
            svg += `<text x="${x}" y="${height - padding.bottom + 15}" text-anchor="middle" fill="#64748b">${labels[i]}</text>`;
        });

        svg += `<text x="${width/2}" y="${height-5}" text-anchor="middle" fill="#475569" font-weight="bold">Inter-DC Bandwidth (Gbps)</text>`;
        svg += `<text x="${15}" y="${height/2}" text-anchor="middle" fill="#475569" font-weight="bold" transform="rotate(-90, 15, ${height/2})">Compute Utilization</text>`;

        // Paths
        seriesData.forEach((points, i) => {
            const pathD = points.map((p, idx) => `${idx === 0 ? 'M' : 'L'} ${scaleX(p.x)} ${scaleY(p.y)}`).join(' ');
            const dash = i === 2 ? 'stroke-dasharray="4,2"' : '';
            svg += `<path d="${pathD}" fill="none" stroke="${seriesConfig[i].color}" stroke-width="2" ${dash} />`;
        });

        // Hover marker (initially hidden)
        svg += `<circle id="hoverMarker" cx="0" cy="0" r="5" fill="white" stroke="black" stroke-width="2" style="display: none;" />`;

        // Legend (Top Left)
        const legendX = padding.left + 15;
        const legendY = padding.top + 10;
        
        // Legend Background
        svg += `<rect x="${legendX - 5}" y="${legendY - 5}" width="180" height="${seriesConfig.length * 15 + 10}" fill="rgba(255,255,255,0.9)" stroke="#e2e8f0" rx="4" />`;

        seriesData.forEach((points, i) => {
            const legY = legendY + i * 15;
            const dash = i === 2 ? 'stroke-dasharray="4,2"' : ''; 
            svg += `<line x1="${legendX}" y1="${legY+5}" x2="${legendX+15}" y2="${legY+5}" stroke="${seriesConfig[i].color}" stroke-width="2" ${dash} />`;
            svg += `<text x="${legendX + 20}" y="${legY + 9}" fill="#475569" style="font-size: 10px; font-weight: 500;">${seriesConfig[i].name}</text>`;
        });

        svg += `</svg>`;
        container.innerHTML = svg;

        // Create tooltip div
        const tooltip = document.createElement('div');
        tooltip.id = 'plotTooltip';
        tooltip.style.cssText = 'position: absolute; visibility: hidden; background-color: rgba(30, 41, 59, 0.95); color: white; padding: 0.5rem 0.75rem; border-radius: 0.375rem; font-size: 0.75rem; pointer-events: none; z-index: 1000; white-space: nowrap;';
        container.appendChild(tooltip);

        // Add hover tooltip functionality
        const svgElement = container.querySelector('svg');
        const hoverMarker = svgElement.querySelector('#hoverMarker');

        if (svgElement && tooltip && hoverMarker) {
            svgElement.addEventListener('mousemove', (e) => {
                const rect = svgElement.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Check if mouse is in plot area
                if (mouseX < padding.left || mouseX > width - padding.right ||
                    mouseY < padding.top || mouseY > height - padding.bottom) {
                    tooltip.style.visibility = 'hidden';
                    hoverMarker.style.display = 'none';
                    return;
                }

                // Convert mouse position to data coordinates
                const xRatio = (mouseX - padding.left) / (width - padding.left - padding.right);
                const bw = Math.exp(minX + xRatio * (maxX - minX));

                // Find closest data point and line
                let closestDistance = Infinity;
                let closestSeries = null;
                let closestPoint = null;

                seriesData.forEach((points, seriesIdx) => {
                    points.forEach(point => {
                        const px = scaleX(point.x);
                        const py = scaleY(point.y);
                        const distance = Math.sqrt(Math.pow(mouseX - px, 2) + Math.pow(mouseY - py, 2));

                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestSeries = seriesIdx;
                            closestPoint = point;
                        }
                    });
                });

                // Only show tooltip if we're close enough to a line (within 30px)
                if (closestDistance < 30 && closestPoint) {
                    const utilization = closestPoint.y.toFixed(1);
                    const bandwidth = closestPoint.x < 1 ?
                        closestPoint.x.toFixed(2) :
                        (closestPoint.x < 10 ? closestPoint.x.toFixed(1) : closestPoint.x.toFixed(0));

                    // Calculate All-Reduce time for this bandwidth
                    const B_bps = closestPoint.x * 1e9;
                    const alpha = 0.002; // 2ms latency
                    const N = getModelSize();
                    const M = parseNumber(document.getElementById('numDatacenters').value);

                    let arTime = 0;
                    let arLabel = '';

                    if (closestSeries === 0) {
                        // Data Parallel: AR time per step
                        const dtype = parseFloat(document.getElementById('dp_dtype').value);
                        const S_total_bits = N * dtype * 8;
                        const overhead_factor = M > 1 ? 2 * (1 - 1/M) : 0;
                        const effective_size = S_total_bits * overhead_factor;
                        arTime = alpha + effective_size / B_bps;
                        arLabel = 'AR time per step';
                    } else if (closestSeries === 1) {
                        // DiLoCo: AR time at sync (not amortized)
                        const dtype = parseFloat(document.getElementById('diloco_dtype').value);
                        const S_outer_bits = N * dtype * 8;
                        const overhead_factor = M > 1 ? 2 * (1 - 1/M) : 0;
                        const effective_size = S_outer_bits * overhead_factor;
                        arTime = alpha + effective_size / B_bps;
                        arLabel = 'AR time at sync';
                    } else if (closestSeries === 2) {
                        // Streaming DiLoCo: AR time per fragment
                        const dtype = parseFloat(document.getElementById('streaming_dtype').value);
                        const P = parseNumber(document.getElementById('streaming_P').value);
                        const S_outer_bits = N * dtype * 8;
                        const fragment_size = S_outer_bits / P;
                        const overhead_factor = M > 1 ? 2 * (1 - 1/M) : 0;
                        const effective_size = fragment_size * overhead_factor;
                        arTime = alpha + effective_size / B_bps;
                        arLabel = 'AR time per fragment';
                    }

                    tooltip.innerHTML = `<strong>${seriesConfig[closestSeries].name}</strong><br/>Bandwidth: ${bandwidth} Gbps<br/>Utilization: ${utilization}%<br/>${arLabel}: ${formatTime(arTime)}`;
                    tooltip.style.visibility = 'visible';

                    // Position relative to the container
                    const containerRect = container.getBoundingClientRect();
                    tooltip.style.left = (e.clientX - containerRect.left + 10) + 'px';
                    tooltip.style.top = (e.clientY - containerRect.top - 10) + 'px';

                    // Show and position the marker
                    const markerX = scaleX(closestPoint.x);
                    const markerY = scaleY(closestPoint.y);
                    hoverMarker.setAttribute('cx', markerX);
                    hoverMarker.setAttribute('cy', markerY);
                    hoverMarker.setAttribute('stroke', seriesConfig[closestSeries].color);
                    hoverMarker.style.display = 'block';
                } else {
                    tooltip.style.visibility = 'hidden';
                    hoverMarker.style.display = 'none';
                }
            });

            svgElement.addEventListener('mouseleave', () => {
                tooltip.style.visibility = 'hidden';
                hoverMarker.style.display = 'none';
            });
        }
    }

    /**
     * Find bandwidth required to reach target utilization using binary search
     */
    function findBandwidthForUtilization(targetUtil, H, bytesPerParam, S, P) {
        const minBw = 0.1;
        const maxBw = 100000;
        const tolerance = 0.5; // 0.5% tolerance

        let low = minBw;
        let high = maxBw;
        let bestBw = null;

        // Binary search for bandwidth
        for (let iter = 0; iter < 50; iter++) {
            const midBw = (low + high) / 2;
            const result = calculateCore(H, bytesPerParam, S, P, midBw);
            const util = result.utilization;

            if (Math.abs(util - targetUtil) < tolerance) {
                bestBw = midBw;
                break;
            }

            if (util < targetUtil) {
                // Need more bandwidth
                low = midBw;
            } else {
                // Need less bandwidth
                high = midBw;
                bestBw = midBw; // Keep track of last successful bandwidth
            }
        }

        return bestBw;
    }

    /**
     * Format bandwidth value for display
     */
    function formatBandwidth(bw) {
        if (bw === null) return '> 1000';
        if (bw < 1) return bw.toFixed(2);
        if (bw < 10) return bw.toFixed(1);
        return Math.round(bw).toString();
    }

    /**
     * Update the bandwidth requirements table
     */
    function updateBandwidthTable() {
        // Get configuration-specific settings
        const dp_dtype = parseFloat(document.getElementById('dp_dtype').value);
        const diloco_dtype = parseFloat(document.getElementById('diloco_dtype').value);
        const diloco_H = parseNumber(document.getElementById('diloco_H').value);
        const streaming_dtype = parseFloat(document.getElementById('streaming_dtype').value);
        const streaming_H = parseNumber(document.getElementById('streaming_H').value);
        const streaming_P = parseNumber(document.getElementById('streaming_P').value);
        const streaming_S = parseNumber(document.getElementById('streaming_S').value);

        const thresholds = [50, 75, 90, 95, 99];

        // Calculate for each method
        const methods = [
            { prefix: 'dp', H: 1, dtype: dp_dtype, S: 0, P: 1 },
            { prefix: 'diloco', H: diloco_H, dtype: diloco_dtype, S: 0, P: 1 },
            { prefix: 'streaming', H: streaming_H, dtype: streaming_dtype, S: streaming_S, P: streaming_P }
        ];

        methods.forEach(method => {
            thresholds.forEach(threshold => {
                const cellId = `${method.prefix}_${threshold}`;
                const cell = document.getElementById(cellId);

                if (cell) {
                    const bw = findBandwidthForUtilization(threshold, method.H, method.dtype, method.S, method.P);
                    cell.textContent = formatBandwidth(bw);

                    // Color code based on bandwidth range
                    if (bw === null || bw > 100) {
                        cell.style.color = 'var(--red-500)';
                        cell.style.fontWeight = '700';
                    } else if (bw > 10) {
                        cell.style.color = 'var(--orange-600)';
                        cell.style.fontWeight = '600';
                    } else {
                        cell.style.color = 'var(--green-600)';
                        cell.style.fontWeight = '600';
                    }
                }
            });
        });
    }

    // ========================================================================
    // URL PARAMETER HANDLING
    // ========================================================================

    /**
     * Update URL with current configuration
     */
    function updateURL() {
        const params = new URLSearchParams();

        // Collect all configuration values
        const config = {
            'N': parseNumber(document.getElementById('modelSizeInput').value),
            'secondsPerStep': parseNumber(document.getElementById('secondsPerStep').value),
            'M': parseNumber(document.getElementById('numDatacenters').value),
            'dp_dtype': document.getElementById('dp_dtype').value,
            'diloco_dtype': document.getElementById('diloco_dtype').value,
            'diloco_H': parseNumber(document.getElementById('diloco_H').value),
            'streaming_dtype': document.getElementById('streaming_dtype').value,
            'streaming_H': parseNumber(document.getElementById('streaming_H').value),
            'streaming_P': parseNumber(document.getElementById('streaming_P').value),
            'streaming_S': parseNumber(document.getElementById('streaming_S').value)
        };

        // Add all params to URL
        for (const [key, value] of Object.entries(config)) {
            params.set(key, value);
        }

        // Update URL without reloading page
        const newURL = window.location.pathname + '?' + params.toString();
        window.history.replaceState({}, '', newURL);
    }

    /**
     * Load configuration from URL parameters
     */
    function loadConfigFromURL() {
        const urlParams = new URLSearchParams(window.location.search);

        // Map of URL param names to input element IDs
        const paramMap = {
            'N': 'modelSizeInput',
            'secondsPerStep': 'secondsPerStep',
            'M': 'numDatacenters',
            'dp_dtype': 'dp_dtype',
            'diloco_dtype': 'diloco_dtype',
            'diloco_H': 'diloco_H',
            'streaming_dtype': 'streaming_dtype',
            'streaming_H': 'streaming_H',
            'streaming_P': 'streaming_P',
            'streaming_S': 'streaming_S'
        };

        let hasParams = false;

        // Load each parameter from URL if present
        for (const [urlParam, elementId] of Object.entries(paramMap)) {
            if (urlParams.has(urlParam)) {
                hasParams = true;
                const value = urlParams.get(urlParam);
                const element = document.getElementById(elementId);

                if (element) {
                    // Special handling for model size input (add commas for >= 1000)
                    if (elementId === 'modelSizeInput') {
                        const val = parseFloat(value) || 10;
                        element.value = val >= 1000 ? val.toLocaleString('en-US') : val.toString();
                    }
                    // For other formatted inputs, apply standard formatting
                    else if (element.classList.contains('formatted-input')) {
                        element.value = formatNumber(value);
                    } else {
                        element.value = value;
                    }
                }
            }
        }

        return hasParams;
    }

    /**
     * Share button functionality - copy URL to clipboard
     */
    document.getElementById('shareBtn').addEventListener('click', async function() {
        const btn = this;
        const originalText = btn.innerHTML;

        try {
            await navigator.clipboard.writeText(window.location.href);

            // Show success feedback
            btn.classList.add('copied');
            btn.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
                Copied!
            `;

            // Reset after 2 seconds
            setTimeout(() => {
                btn.classList.remove('copied');
                btn.innerHTML = originalText;
            }, 2000);
        } catch (err) {
            // Fallback for browsers that don't support clipboard API
            console.error('Failed to copy:', err);

            // Show error feedback
            btn.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12.01" y2="16"></line>
                </svg>
                Failed
            `;

            setTimeout(() => {
                btn.innerHTML = originalText;
            }, 2000);
        }
    });

    // Load config from URL on page load, then render
    loadConfigFromURL();
    updateConfigurations();
</script>

</body>
</html>